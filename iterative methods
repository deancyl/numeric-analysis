# Jacobi method
import numpy as np
def u_need_v(v):
    return ((5 - v)/3)
def v_need_u(u):
    return ((5 - u)/2)
def Jacobi_2():
  p = [0,0]
  while True:
      yield np.array([u_need_v(p[0]),v_need_u(p[1])])
      p = v_need_u(p[1]),u_need_v(p[0]) 
for i , r in enumerate(Jacobi_2()):
    if i > 10 :
        break
    print(r) 
    
# or method 2 
import numpy as np
import scipy.linalg as sl

D = np.mat([[3,0],[0,2]])
D_inverse = sl.inv(D)
b = np.mat([5,5])
LU = np.mat([[0,1],[1,0]])

def Jacobi(parameters):
    return np.array(D_inverse @ (b.T - LU @ np.mat([parameters[0][0],parameters[0][1]]).T)).T
    parameters = np.array(D_inverse @ (b.T - LU @ np.mat([parameters[0][0],parameters[0][1]]).T)).T
    parameters[0][0] , parameters[0][1] = parameters[0][1] , parameters[0][0]

parameters = [[0,0]]
for _ in range(15):
    p = Jacobi(parameters)
    print(p)
    parameters = Jacobi(p)
    print(parameters)
    
# Gauss_Seidel
def Gauss_Seidel():
    p = 0
    while True :
        u = u_need_v(p)
        v = v_need_u(u)
        p = v
        yield (u,v)
for i , r in enumerate(xGauss_Seidel()):
    if i > 10 :
        break
    print(i,r)
    
# Gauss_Seidel 3d 
def u_need_vw(v,w):
    return ((4.0 - v + w)/3)
def v_need_uw(u,w):
    '''
    u -> +1
    w -> 0 
    '''
    return ((1-2*u-w)/4.0)
def w_need_uv(u,v):
    '''
    u -> +1 
    v -> +1
    '''
    return ((1+u-2*v)/5)
def Gauss_Seidel_3d():
  p = (0,0) # v ,w need
  while True :
      u = u_need_vw(p[0],p[1])
      v = v_need_uw(u,p[1])
      w = w_need_uv(u,v)
      p = (v,w)
      yield (u,v,w)
for i , r in enumerate(Gauss_Seidel_3d()):
    if i > 10 :
        break
    print(r)

# SOR
def u_need_uvw(u,v,w,omega):
    '''
    output -> +1
    input -> 0
    '''
    return (1.0-omega)*u+omega*((4-v+w)/3.0)
def v_need_vuw(v,u,w,omega):
    '''
    output -> +1
    input -> u +1 ,else 0
    '''
    return (1.0-omega)*v+omega*(1-2*u-w)/4.0
def w_need_wuv(w,u,v,omega):
    '''
    only w -> 0 ,else +1
    '''
    return (1-omega)*w+omega*(1+u-2*v)/5.0
def SOR(omega = 1.25):
    p = (0,0,0)
    while True :
        u = u_need_uvw(p[0],p[1],p[2],omega)
        v = v_need_vuw(p[1],u,p[2],omega)
        w = w_need_wuv(p[2],u,v,omega)
        p = (u,v,w)
        yield (u,v,w)
for i ,r in enumerate(SOR()):
    if i > 10 :
        break
    print(r)        
